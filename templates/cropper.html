<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–†–µ–¥–∞–∫—Ç–æ—Ä –æ–±—Ä–µ–∑–∫–∏</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body { margin: 0; background: #222; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #toolbar { background: #333; height: 50px; display: flex; align-items: center; padding: 0 15px; border-bottom: 1px solid #444; color: #ccc; gap: 10px; }
        #workspace { flex: 1; position: relative; background: #111; }
    </style>
</head>
<body>

<div id="toolbar">
    <button class="btn" onclick="window.location.href='/'" title="Home">üè†</button>
    {% if project %}
        <button class="btn" onclick="window.location.href='/project/{{ project }}'" title="–ù–∞–∑–∞–¥ –∫ –ø—Ä–æ–µ–∫—Ç—É">üìã –ü—Ä–æ–µ–∫—Ç</button>
        <button class="btn" onclick="window.location.href='/editor?image={{ filename }}&project={{ project }}'" title="–†–µ–¥–∞–∫—Ç–æ—Ä —Å–µ–≥–º–µ–Ω—Ç–æ–≤">üìã –°–µ–≥–º–µ–Ω—Ç—ã</button>
        <button class="btn" onclick="window.location.href='/text_editor?image={{ filename }}&project={{ project }}'" title="–†–µ–¥–∞–∫—Ç–æ—Ä —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è">üî§ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å</button>
    {% else %}
        <button class="btn" onclick="window.location.href='/editor?image={{ filename }}'" title="–†–µ–¥–∞–∫—Ç–æ—Ä —Å–µ–≥–º–µ–Ω—Ç–æ–≤">üìã –°–µ–≥–º–µ–Ω—Ç—ã</button>
        <button class="btn" onclick="window.location.href='/text_editor?image={{ filename }}'" title="–†–µ–¥–∞–∫—Ç–æ—Ä —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è">üî§ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å</button>
    {% endif %}
    <div class="sep"></div>
    <button class="btn" onclick="goImage(-1)">&lt;</button>
    <button class="btn" onclick="goImage(1)">&gt;</button>
    <span style="font-size:0.9em; max-width:200px; white-space:nowrap; overflow:hidden; color:#aaa;">{{ filename }}</span>

    <div style="flex:1"></div>
    <div style="font-size:0.8em; color:#888; margin-right:15px;">
        Shift: –ü—Ä–æ–ø–æ—Ä—Ü–∏–∏ | –ü–ö–ú: –û–±–∑–æ—Ä
    </div>
    <button class="btn btn-primary" onclick="applyCrop()">‚úÇÔ∏è –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
</div>

<div id="workspace">
    <canvas id="c"></canvas>
</div>

<script src="/static/js/api.js"></script>
<script>
    const filename = "{{ filename }}";
    const canvas = new fabric.Canvas('c', {
        selection: false,
        backgroundColor: "#111",
        uniScaleKey: 'shiftKey',
        uniformScaling: false,
        fireRightClick: true,
        stopContextMenu: true,
        // –£–±–∏—Ä–∞–µ–º "–º–∞–≥–Ω–∏—Ç–Ω—ã–π" —ç—Ñ—Ñ–µ–∫—Ç Retina-–¥–∏—Å–ø–ª–µ–µ–≤
        enableRetinaScaling: false, 
        // –¢–æ—á–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞ —Ü–µ–ª–∏ (—É–º–µ–Ω—å—à–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø—Ä—ã–∂–∫–æ–≤ –ø—Ä–∏ –∑–∞—Ö–≤–∞—Ç–µ)
        targetFindTolerance: 1 
    });

    let cropRect = null;
    let imgObj = null;
    let imageList = [];

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ —Ç–æ—á–∫–∏ –≤–æ–∫—Ä—É–≥ —Ü–µ–Ω—Ç—Ä–∞
    function rotate_pointJS(x, y, cx, cy, angle_deg) {
        const rad = angle_deg * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);

        const nx = cx + (x - cx) * cos - (y - cy) * sin;
        const ny = cy + (x - cx) * sin + (y - cy) * cos;
        return [nx, ny];
    }

    (async () => {
        resize();
        window.addEventListener('resize', resize);

        imageList = await API.listImages();

        fabric.Image.fromURL(`/data/originals/${filename}`, img => {
            imgObj = img;
            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));

            fitImageHeight(img);
            loadExistingCropData();
        });
    })();

    function resize() {
        const el = document.getElementById('workspace');
        canvas.setWidth(el.clientWidth);
        canvas.setHeight(el.clientHeight);
    }

    function fitImageHeight(img) {
        const scale = (canvas.height / img.height) * 0.9;
        canvas.setZoom(scale);

        const vpt = canvas.viewportTransform;
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Math.floor –∏–ª–∏ Math.round, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å—É–±–ø–∏–∫—Å–µ–ª—å–Ω–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
        vpt[4] = Math.floor((canvas.width - img.width * scale) / 2);
        vpt[5] = Math.floor((canvas.height - img.height * scale) / 2);
        canvas.requestRenderAll();
    }

    async function loadExistingCropData() {
        const data = await API.loadAnnotation(filename);
        let corners = [];

        if (data.crop_params && data.crop_params.corners) {
            // –ï—Å–ª–∏ –µ—Å—Ç—å —É–≥–ª—ã –≤ crop_params, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö –Ω–∞–ø—Ä—è–º—É—é
            corners = data.crop_params.corners;
        } else if (data.processing_params) {
            // –ï—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–≥–ª—ã
            const procParams = data.processing_params;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–≥–ª–æ–≤
            const quad_coords = procParams.quad_coords;
            
            // quad_coords —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø–æ—Ä—è–¥–∫–µ, —Ç—Ä–µ–±—É–µ–º–æ–º Pillow: TL, BL, BR, TR
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Ö –≤ –ø–æ—Ä—è–¥–∫–µ: TL, TR, BR, BL
            corners = [
                {x: quad_coords[0], y: quad_coords[1]},  // –≤–µ—Ä—Ö–Ω–∏–π –ª–µ–≤—ã–π (TL)
                {x: quad_coords[6], y: quad_coords[7]},  // –≤–µ—Ä—Ö–Ω–∏–π –ø—Ä–∞–≤—ã–π (TR)
                {x: quad_coords[4], y: quad_coords[5]},  // –Ω–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π (BR)
                {x: quad_coords[2], y: quad_coords[3]}   // –Ω–∏–∂–Ω–∏–π –ª–µ–≤—ã–π (BL)
            ];
        } else if (data.crop_params) {
            // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –≤—ã—á–∏—Å–ª—è–µ–º —É–≥–ª—ã
            const cropParams = data.crop_params;
            const centerX = cropParams.x + cropParams.w / 2;
            const centerY = cropParams.y + cropParams.h / 2;
            const angle = cropParams.angle || 0;
            
            // –í—ã—á–∏—Å–ª—è–µ–º —É–≥–ª—ã –¥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞
            const unrotatedCorners = [
                {x: cropParams.x, y: cropParams.y},                           // –≤–µ—Ä—Ö–Ω–∏–π –ª–µ–≤—ã–π
                {x: cropParams.x + cropParams.w, y: cropParams.y},            // –≤–µ—Ä—Ö–Ω–∏–π –ø—Ä–∞–≤—ã–π
                {x: cropParams.x + cropParams.w, y: cropParams.y + cropParams.h}, // –Ω–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π
                {x: cropParams.x, y: cropParams.y + cropParams.h}             // –Ω–∏–∂–Ω–∏–π –ª–µ–≤—ã–π
            ];
            
            // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —É–≥–ª—ã –Ω–∞ —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —É–≥–ª—ã –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            corners = unrotatedCorners.map(corner => {
                const rotatedCorner = rotate_pointJS(corner.x, corner.y, centerX, centerY, angle);
                return {x: rotatedCorner[0], y: rotatedCorner[1]};
            });
        } else {
            // –ï—Å–ª–∏ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, —Å–æ–∑–¥–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
            const margin = 0.05; // 5% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            const width = imgObj.width * (1 - 2 * margin);
            const height = imgObj.height * (1 - 2 * margin);
            
            corners = [
                {x: imgObj.width * margin, y: imgObj.height * margin},                    // –≤–µ—Ä—Ö–Ω–∏–π –ª–µ–≤—ã–π
                {x: imgObj.width * margin + width, y: imgObj.height * margin},            // –≤–µ—Ä—Ö–Ω–∏–π –ø—Ä–∞–≤—ã–π
                {x: imgObj.width * margin + width, y: imgObj.height * margin + height},   // –Ω–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π
                {x: imgObj.width * margin, y: imgObj.height * margin + height}            // –Ω–∏–∂–Ω–∏–π –ª–µ–≤—ã–π
            ];
        }

        addCropRectFromCorners(corners);
    }

    function addCropRect(left, top, width, height, angle) {
        const z = canvas.getZoom();

        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≤ —Ü–µ–Ω—Ç—Ä, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–∫–æ—Å–æ–≤
        const centerX = left + width / 2;
        const centerY = top + height / 2;

        cropRect = new fabric.Rect({
            left: centerX,
            top: centerY,
            width: width,
            height: height,
            angle: angle,

            originX: 'center',
            originY: 'center',

            fill: 'rgba(255, 255, 255, 0.0001)',
            stroke: 'yellow',
            strokeWidth: 2 / z,
            strokeUniform: true,

            objectCaching: false,

            transparentCorners: false,
            cornerColor: 'white',
            cornerStyle: 'circle',
            cornerSize: 3 / z
        });

        canvas.add(cropRect);
        canvas.setActiveObject(cropRect);

        cropRect.on('moving', function(e) {
            // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ä–∞–º–∫–∏ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å –∫–∞–∂–¥—ã–º –∫–∞–¥—Ä–æ–º
            this.setCoords();
            canvas.requestRenderAll();
        });
    }

    function addCropRectFromCorners(corners) {
        // –û—á–∏—â–∞–µ–º –∫–∞–Ω–≤–∞—Å –æ—Ç —Å—Ç–∞—Ä—ã—Ö —Ä–∞–º–æ–∫
        if (cropRect) canvas.remove(cropRect);

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è Fabric (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã "–º–∏—Ä–∞" –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
        const centerX = corners.reduce((sum, c) => sum + c.x, 0) / 4;
        const centerY = corners.reduce((sum, c) => sum + c.y, 0) / 4;
        
        const width = Math.sqrt(Math.pow(corners[0].x - corners[1].x, 2) + Math.pow(corners[0].y - corners[1].y, 2));
        const height = Math.sqrt(Math.pow(corners[1].x - corners[2].x, 2) + Math.pow(corners[1].y - corners[2].y, 2));
        
        const dx = corners[1].x - corners[0].x;
        const dy = corners[1].y - corners[0].y;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        const z = canvas.getZoom();

        cropRect = new fabric.Rect({
            left: centerX,
            top: centerY,
            width: width,
            height: height,
            angle: angle,
            originX: 'center',
            originY: 'center',
            fill: 'rgba(255, 255, 0, 0.1)',
            stroke: 'yellow',
            strokeWidth: 2 / z,
            strokeUniform: true,
            cornerSize: 8 / z,
            transparentCorners: false,
            cornerColor: 'white',
            cornerStyle: 'circle'
        });

        canvas.add(cropRect);
        canvas.setActiveObject(cropRect);
        canvas.requestRenderAll();
    }
    


    canvas.on('mouse:wheel', (opt) => {
        let zoom = canvas.getZoom();
        zoom *= 0.999 ** opt.e.deltaY;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.01) zoom = 0.01;
        canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
        
        if(cropRect) {
            cropRect.set('strokeWidth', 2 / zoom);
            cropRect.set('cornerSize', 4 / zoom);
        }
        opt.e.preventDefault();
        opt.e.stopPropagation();
    });

    let isPanning = false, lastMouse = {x:0, y:0};
    canvas.on('mouse:down', opt => {
        if(opt.e.button===2 || opt.e.altKey) {
            isPanning=true; lastMouse={x:opt.e.clientX, y:opt.e.clientY};
            canvas.defaultCursor = 'grab';
        }
    });
    canvas.on('mouse:move', opt => {
        if(isPanning) {
            canvas.relativePan(new fabric.Point(opt.e.clientX-lastMouse.x, opt.e.clientY-lastMouse.y));
            lastMouse={x:opt.e.clientX, y:opt.e.clientY};
            if(cropRect) {
                cropRect.setCoords(); // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≥—Ä–∞–Ω–∏—Ü
            }
        }
    });
    canvas.on('mouse:up', () => { 
        if(isPanning) {
            isPanning=false; 
            canvas.defaultCursor = 'default';
            canvas.setViewportTransform(canvas.viewportTransform);
            if(cropRect) cropRect.setCoords();
        }
    });
    document.oncontextmenu = () => false;

    async function applyCrop() {
        if (!cropRect) return;

        // 1. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –º–∞—Ç—Ä–∏—Ü—É —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∫–∞–Ω–≤–∞—Å–∞
        const vpt = canvas.viewportTransform;
        // 2. –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –µ—ë, —á—Ç–æ–±—ã –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –∏–∑ "—ç–∫—Ä–∞–Ω–Ω—ã—Ö" –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ "–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"
        const invVpt = fabric.util.invertTransform(vpt);

        // 3. –ë–µ—Ä–µ–º —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–≥–ª–æ–≤ —Ä–∞–º–∫–∏ (oCoords —Å–æ–¥–µ—Ä–∂–∏—Ç tl, tr, br, bl)
        // –í–∞–∂–Ω–æ: oCoords - —ç—Ç–æ —Ç–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ —ç–∫—Ä–∞–Ω–µ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–π
        const coords = cropRect.oCoords;

        const getImgPoint = (pt) => {
            const p = fabric.util.transformPoint({ x: pt.x, y: pt.y }, invVpt);
            return { x: Math.round(p.x), y: Math.round(p.y) };
        };

        const cropData = {
            // –°—Ç—Ä–æ–≥–∏–π –ø–æ—Ä—è–¥–æ–∫: Top-Left, Top-Right, Bottom-Right, Bottom-Left
            corners: [
                getImgPoint(coords.tl),
                getImgPoint(coords.tr),
                getImgPoint(coords.br),
                getImgPoint(coords.bl)
            ]
        };

        const resp = await fetch('/api/crop', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ image_name: filename, box: cropData })
        });

        if (resp.ok) {
            goImage(1);
        } else {
            alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏');
        }
    }

    function goImage(dir) {
        const idx = imageList.indexOf(filename);
        if (idx === -1) return;
        const newIdx = (idx + dir + imageList.length) % imageList.length;
        window.location.href = `?image=${imageList[newIdx]}`;
    }
</script>
</body>
</html>